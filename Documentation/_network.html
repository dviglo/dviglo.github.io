<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Urho3D: Networking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Urho3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Networking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Network subsystem provides reliable and unreliable UDP messaging using SLikeNet. A server can be created that listens for incoming connections, and client connections can be made to the server. After connecting, code running on the server can assign the client into a scene to enable scene replication, provided that when connecting, the client specified a blank scene for receiving the updates.</p>
<p>Scene replication is one-directional: the server always has authority and sends scene updates to the client at a fixed update rate, by default 30 FPS. The client responds by sending controls updates (buttons, yaw and pitch + possible extra data) also at a fixed rate.</p>
<p>Bidirectional communication between the server and the client can happen either using raw network messages, which are binary-serialized data, or remote events, which operate like ordinary events, but are processed on the receiving end only. Code on the server can send messages or remote events either to one client, all clients assigned into a particular scene, or to all connected clients. In contrast the client can only send messages or remote events to the server, not directly to other clients.</p>
<p>Note that if a particular networked application does not need scene replication, network messages and remote events can also be transmitted without assigning the client to a scene. The Chat example does just that: it does not create a scene either on the server or the client.</p>
<h1><a class="anchor" id="Network_Connecting"></a>
Connecting to a server</h1>
<p>Starting the server and connecting to it both happen through the Network subsystem. See StartServer() and Connect(). A UDP port must be chosen; the examples use the port 2345.</p>
<p>Note the scene (to be used for replication) and identity VariantMap supplied as parameters when connecting. The identity data can contain for example the user name or credentials, it is completely application-specified. The identity data is sent right after connecting and causes the E_CLIENTIDENTITY event to be sent on the server when received. By subscribing to this event, server code can examine incoming connections and accept or deny them. The default is to accept all connections.</p>
<p>After connecting successfully, client code can get the Connection object representing the server connection, see GetServerConnection(). Likewise, on the server a Connection object will be created for each connected client, and these can be iterated through. This object is used to send network messages or remote events to the remote peer, to assign the client into a scene (on the server only), or to disconnect.</p>
<h1><a class="anchor" id="Network_NAT_Punchtrough"></a>
NAT punchtrough</h1>
<p>It is possible to use NAT punchtrough functionality with network subsystem. This requires NAT punchtrough master server to be running on a public host. To set it up you first have to tell the networking subsystem the IP address or a domain name to NAT punchtrough master server, to do this, call SetNATServerInfo().</p>
<p>Server: Server should be started first by calling StartServer() and after that StartNATClient(). If connection to NAT punchtrough master server succeeds, unique GUID will be generated. Clients should use this generated GUID to connect to this server.</p>
<p>Client: When server has been successfully started and connected with NAT punchtrough master server, clients should connect to server by calling AttemptNATPunchtrough() and pass in the server generated GUID.</p>
<p>For a demonstration, check example 52_NATPunchtrough.</p>
<h1><a class="anchor" id="Network_Lan_Discovery"></a>
Lan Discovery</h1>
<p>Network subsystem supports LAN discovery mode to search for running servers. When creating server you can set what data should be sent to the network when someone starts LAN discovery mode, see SetDiscoveryBeacon(). This data can contain any information about the server. To start LAN discovery mode you should call DiscoverHosts(). When server is found, "NetworkHostDiscovered" event will be sent out.</p>
<p>For a demonstration, check example 53_LANDiscovery.</p>
<h1><a class="anchor" id="Network_Replication"></a>
Scene replication</h1>
<p>Network replication of scene content has been implemented in a straightforward manner, using <a class="el" href="_serialization.html">attributes</a>. Nodes and components that have not been created in local mode - see the CreateMode parameter of CreateChild() or CreateComponent() - will be automatically replicated. Note that a replicated component created into a local node will not be replicated, as the node's locality is checked first.</p>
<p>The CreateMode translates into two different node and component ID ranges - replicated ID's range from 0x1 to 0xffffff, while local ID's range from 0x1000000 to 0xffffffff. This means there is a maximum of 16777215 replicated nodes or components in a scene.</p>
<p>If the scene was originally loaded from a file on the server, the client will also load the scene from the same file first. In this case all predefined, static objects such as the world geometry should be defined as local nodes, so that they are not needlessly retransmitted through the network during the initial update, and do not exhaust the more limited replicated ID range.</p>
<p>The server can be made to transmit needed resource packages to the client. This requires attaching the package files to the Scene by calling AddRequiredPackageFile(). On the client, a cache directory for the packages must be chosen before receiving them is possible: see SetPackageCacheDir().</p>
<p>There are some things to watch out for:</p>
<ul>
<li>When a client is assigned to a scene, the client will first remove all existing replicated scene nodes from the scene, to prepare for receiving objects from the server. This means that for example a client's camera should be created into a local node, otherwise it will be removed when connecting.</li>
<li>After connecting to a server, the client should not create, update or remove non-local nodes or components on its own. However, to create client-side special effects and such, the client can freely manipulate local nodes.</li>
<li>A node's user variables VariantMap will be automatically replicated on a per-variable basis. This can be useful in transmitting data shared by several components, for example the player's score or health.</li>
<li>To implement interpolation, exponential smoothing of the nodes' rendering transforms is enabled on the client. It can be controlled by two properties of the Scene, the smoothing constant and the snap threshold. Snap threshold is the distance between network updates which, if exceeded, causes the node to immediately snap to the end position, instead of moving smoothly. See SetSmoothingConstant() and SetSnapThreshold().</li>
<li>Position and rotation are Node attributes, while linear and angular velocities are RigidBody attributes. To cut down on the needed network bandwidth the physics components can be created as local on the server: in this case the client will not see them at all, and will only interpolate motion based on the node's transform changes. Replicating the actual physics components allows the client to extrapolate using its own physics simulation, and to also perform collision detection, though always non-authoritatively.</li>
<li>By default the physics simulation also performs interpolation to enable smooth motion when the rendering framerate is higher than the physics FPS. This should be disabled on the server scene to ensure that the clients do not receive interpolated and therefore possibly non-physical positions and rotations. See SetInterpolation().</li>
<li>AnimatedModel does not replicate animation by itself. Rather, AnimationController will replicate its command state (such as "fade this animation in, play that animation at 1.5x speed.") To turn off animation replication, create the AnimationController as local. To ensure that also the first animation update will be received correctly, always create the AnimatedModel component first, then the AnimationController.</li>
<li>Networked attributes can either be in delta update or latest data mode. Delta updates are small incremental changes and must be applied in order, which may cause increased latency if there is a stall in network message delivery eg. due to packet loss. High volume data such as position, rotation and velocities are transmitted as latest data, which does not need ordering, instead this mode simply discards any old data received out of order. Note that node and component creation (when initial attributes need to be sent) and removal can also be considered as delta updates and are therefore applied in order.</li>
<li>To avoid going through the whole scene when sending network updates, nodes and components explicitly mark themselves for update when necessary. When writing your own replicated C++ components, call MarkNetworkUpdate() in member functions that modify any networked attribute.</li>
<li>The server update logic orders replication messages so that parent nodes are created and updated before their children. Remote events are queued and only sent after the replication update to ensure that if they originate from a newly created node, it will already exist on the receiving end. However, it is also possible to specify unordered transmission for a remote event, in which case that guarantee does not hold.</li>
<li>Nodes have the concept of the owner connection (for example the player that is controlling a specific game object), which can be set in server code. This property is not replicated to the client. Messages or remote events can be used instead to tell the players what object they control.</li>
<li>If you want to run the same server logic for both the locally connecting client as well as remote clients, you can use both the server &amp; client functionality in Network subsystem simultaneously. However in this case you need 2 copies of the scene: server and client. Only the client scene should be rendered on the local client, while the server scene is used for simulation only.</li>
</ul>
<h1><a class="anchor" id="Network_InterestManagement"></a>
Interest management</h1>
<p>Scene replication includes a simple, distance-based interest management mechanism for reducing bandwidth use. To use, create the NetworkPriority component to a Node you wish to apply interest management to. The component can be created as local, as it is not important to the clients.</p>
<p>This component has three parameters for controlling the update frequency: base priority, distance factor, and minimum priority.</p>
<p>A current priority value is calculated on each server update as "base priority - distance factor * distance." Additionally, it can never go lower than the minimum priority. This value is then added to an update accumulator. Whenever the update accumulator reaches 100.0, the attribute changes to the node and its components are sent, and the accumulator is reset.</p>
<p>The default values are base priority 100.0, distance factor 0.0, and minimum priority 0.0. This means that by default an update is always sent (which is also the case if the node has no NetworkPriority component.) Additionally, there is a rule that the node's owner connection always receives updates at full frequency. This rule can be controlled by calling SetAlwaysUpdateOwner().</p>
<p>Calculating the distance requires the client to tell its current observer position (typically, either the camera's or the player character's world position.) This is accomplished by the client code calling SetPosition() on the server connection. The client can also tell its current observer rotation by calling SetRotation() but that will only be useful for custom logic, as it is not used by the NetworkPriority component.</p>
<p>For now, creation and removal of nodes is always sent immediately, without consulting interest management. This is based on the assumption that nodes' motion updates consume the most bandwidth.</p>
<h1><a class="anchor" id="Network_Controls"></a>
Client controls update</h1>
<p>The Controls structure is used to send controls information from the client to the server, by default also at 30 FPS. This includes held down buttons, which is an application-defined 32-bit bitfield, floating point yaw and pitch, and possible extra data (for example the currently selected weapon) stored within a VariantMap.</p>
<p>It is up to the client code to ensure they are kept up-to-date, by calling SetControls() on the server connection. The event E_NETWORKUPDDATE will be sent to remind of the impending update, and the event E_NETWORKUPDATESENT will be sent after the update. The controls can then be inspected on the server side by calling GetControls().</p>
<p>The controls update message also includes a running 8-bit timestamp, see GetTimeStamp(), and the client's observer position / rotation for interest management. To conserve bandwidth, the position and rotation values are left out if they have never been assigned.</p>
<h1><a class="anchor" id="Network_ClientPrediction"></a>
Client-side prediction</h1>
<p>Urho3D does not implement built-in client-side prediction for player controllable objects due to the difficulty of rewinding and resimulating a generic physics simulation. However, when not using physics for player movement, it is possible to intercept the authoritative network updates from the server and build a prediction system on the application level.</p>
<p>By calling SetInterceptNetworkUpdate() the update of an individual networked attribute is redirected to send an event (E_INTERCEPTNETWORKUPDATE) instead of applying the attribute value directly. This should be called on the client for the node or component that is to be predicted. For example to redirect a Node's position update:</p>
<div class="fragment"><div class="line">node-&gt;SetInterceptNetworkUpdate(<span class="stringliteral">&quot;Network Position&quot;</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>The event includes the attribute name, index, new value as a Variant, and the latest 8-bit controls timestamp that the server has seen from the client. Typically, the event handler would store the value that arrived from the server and set an internal "update arrived" flag, which the application logic update code could use later on the same frame, by taking the server-sent value and replaying any user input on top of it. The timestamp value can be used to estimate how many client controls packets have been sent during the roundtrip time, and how much input needs to be replayed.</p>
<h1><a class="anchor" id="Network_Messages"></a>
Raw network messages</h1>
<p>All network messages have an integer ID. The first ID you can use for custom messages is 153 (lower ID's are either reserved for SLikeNet's or the Network subsystem's internal use.) Messages can be sent either unreliably or reliably, in-order or unordered. The data payload is simply raw binary data that can be crafted by using for example VectorBuffer.</p>
<p>To send a message to a Connection, use its SendMessage() function. On the server, messages can also be broadcast to all client connections by calling the BroadcastMessage() function.</p>
<p>When a message is received, and it is not an internal protocol message, it will be forwarded as the E_NETWORKMESSAGE event. See the Chat example for details of sending and receiving.</p>
<p>For high performance, consider using unordered messages, because for in-order messages there is only a single channel within the connection, and all previous in-order messages must arrive first before a new one can be processed.</p>
<h1><a class="anchor" id="Network_RemoteEvents"></a>
Remote events</h1>
<p>A remote event consists of its event type (name hash), a flag that tells whether it is to be sent in-order or unordered, and the event data VariantMap. It can optionally be set to originate from a specific Node in the receiver's scene ("remote node event.")</p>
<p>To send a remote event to a Connection, use its SendRemoteEvent() function. To broadcast remote events to several connections at once (server only), use Network's BroadcastRemoteEvent() function.</p>
<p>For safety, allowed remote event types must be registered. See RegisterRemoteEvent(). The registration affects only receiving events; sending whatever event is always allowed. There is a fixed blacklist of event types defined in Source/Urho3D/Network/Network.cpp that pose a security risk and are never allowed to be registered for reception; for example E_CONSOLECOMMAND.</p>
<p>Like with ordinary events, in script remote event types are strings instead of name hashes for convenience.</p>
<p>Remote events will always have the originating connection as a parameter in the event data. Here is how to get it in both C++ and script (in C++, include NetworkEvents.h):</p>
<p>C++: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>RemoteEventData;</div>
<div class="line">Connection* remoteSender = <span class="keyword">static_cast&lt;</span>Connection*<span class="keyword">&gt;</span>(eventData[P_CONNECTION].GetPtr());</div>
</div><!-- fragment --><p>Script: </p><div class="fragment"><div class="line">Connection@ remoteSender = eventData[<span class="stringliteral">&quot;Connection&quot;</span>].GetPtr();</div>
</div><!-- fragment --><h1><a class="anchor" id="Network_HttpRequests"></a>
HTTP requests</h1>
<p>In addition to UDP messaging, the network subsystem allows to make HTTP requests. Use the MakeHttpRequest() function for this. You can specify the URL, the verb to use (default GET if empty), optional headers and optional post data. The HttpRequest object that is returned acts like a Deserializer, and you can read the response data in suitably sized chunks. After the whole response is read, the connection closes. The connection can also be closed early by allowing the request object to expire.</p>
<h1><a class="anchor" id="Network_Simulation"></a>
Network conditions simulation</h1>
<p>The Network subsystem can optionally add delay to sending packets, as well as simulate packet loss. See SetSimulatedLatency() and SetSimulatedPacketLoss(). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 13 2021 12:59:30 for Urho3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<!-- Dviglo: Добавленный код -->
<script>
function GetRootPath()
{
    return "";
}
</script>
<script defer src='Addon.js'></script>
</body>
</html>
